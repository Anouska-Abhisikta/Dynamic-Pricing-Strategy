# -*- coding: utf-8 -*-
"""Dynamic Pricing Strategy.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1hCmApaTKdoQEjxDkYnS4iTnrpMduVD1D
"""

#Importing Libraries
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go

#Importing dataset
data = pd.read_csv("dynamic_pricing.csv")
print(data.head())

"""Exploratory Data Analysis(EDA)"""

#Summary
print(data.describe())

#Relationship between expected ride duration and the historical cost of the ride
fig = px.scatter(data, x='Expected_Ride_Duration',
                 y='Historical_Cost_of_Ride',
                 title='Expected Ride Duration vs. Historical Cost of Ride',
                 trendline='ols')
fig.show()

#Distribution of the historical cost of rides based on the vehicle type
fig = px.box(data, x='Vehicle_Type',
             y='Historical_Cost_of_Ride',
             title='Historical Cost of Ride Distribution by Vehicle Type')
fig.show()

#correlation matrix
corr_matrix = data.corr()

fig = go.Figure(data=go.Heatmap(z=corr_matrix.values,
                                x=corr_matrix.columns,
                                y=corr_matrix.columns,
                                colorscale='Viridis'))
fig.update_layout(title='Correlation Matrix')
fig.show()

#Customer Loyalty Analysis
fig = px.box(data, x='Customer_Loyalty_Status',
             y='Historical_Cost_of_Ride',
             title='Historical Cost of Ride Distribution by Customer Loyalty Status')
fig.show()

#Time of Booking Analysis
fig = px.box(data, x='Time_of_Booking',
             y='Historical_Cost_of_Ride',
             title='Historical Cost of Ride Distribution by Time of Booking')
fig.show()

#Location Based Analysis
fig = px.box(data, x='Location_Category',
             y='Historical_Cost_of_Ride',
             title='Historical Cost of Ride Distribution by Location Category')
fig.show()

#Rider-Driver Relationship
fig = px.scatter(data, x='Number_of_Riders',
                 y='Number_of_Drivers',
                 title='Number of Riders vs. Number of Drivers')
fig.show()

#Average Rating Analysis
fig = px.scatter(data, x='Average_Ratings',
                 y='Historical_Cost_of_Ride',
                 title='Average Ratings vs. Historical Cost of Ride')
fig.show()

"""Implementing Dynamic Pricing Strategy"""

import numpy as np

# Calculate demand_multiplier based on percentile for high and low demand
high_demand_percentile = 75
low_demand_percentile = 25

data['demand_multiplier'] = np.where(data['Number_of_Riders'] > np.percentile(data['Number_of_Riders'], high_demand_percentile),
                                     data['Number_of_Riders'] / np.percentile(data['Number_of_Riders'], high_demand_percentile),
                                     data['Number_of_Riders'] / np.percentile(data['Number_of_Riders'], low_demand_percentile))

# Calculate supply_multiplier based on percentile for high and low supply
high_supply_percentile = 75
low_supply_percentile = 25

data['supply_multiplier'] = np.where(data['Number_of_Drivers'] > np.percentile(data['Number_of_Drivers'], low_supply_percentile),
                                     np.percentile(data['Number_of_Drivers'], high_supply_percentile) / data['Number_of_Drivers'],
                                     np.percentile(data['Number_of_Drivers'], low_supply_percentile) / data['Number_of_Drivers'])

# Define price adjustment factors for high and low demand/supply
demand_threshold_high = 1.2  # Higher demand threshold
demand_threshold_low = 0.8  # Lower demand threshold
supply_threshold_high = 0.8  # Higher supply threshold
supply_threshold_low = 1.2  # Lower supply threshold

# Calculate adjusted_ride_cost for dynamic pricing
data['adjusted_ride_cost'] = data['Historical_Cost_of_Ride'] * (
    np.maximum(data['demand_multiplier'], demand_threshold_low) *
    np.maximum(data['supply_multiplier'], supply_threshold_high)
)

# Calculate the profit percentage for each ride
data['profit_percentage'] = ((data['adjusted_ride_cost'] - data['Historical_Cost_of_Ride']) / data['Historical_Cost_of_Ride']) * 100
# Identify profitable rides where profit percentage is positive
profitable_rides = data[data['profit_percentage'] > 0]

# Identify loss rides where profit percentage is negative
loss_rides = data[data['profit_percentage'] < 0]


import plotly.graph_objects as go

# Calculate the count of profitable and loss rides
profitable_count = len(profitable_rides)
loss_count = len(loss_rides)

# Create a donut chart to show the distribution of profitable and loss rides
labels = ['Profitable Rides', 'Loss Rides']
values = [profitable_count, loss_count]

fig = go.Figure(data=[go.Pie(labels=labels, values=values, hole=0.4)])
fig.update_layout(title='Profitability of Rides (Dynamic Pricing vs. Historical Pricing)')
fig.show()

#Relationship between the expected ride duration and the cost of the ride based on the dynamic pricing strategy
fig = px.scatter(data,
                 x='Expected_Ride_Duration',
                 y='adjusted_ride_cost',
                 title='Expected Ride Duration vs. Cost of Ride',
                 trendline='ols')
fig.show()

# Assuming 'Time_of_Booking' contains a string representation of time (e.g., 'Night')
# You need to convert it to a format that can be used for time-based pricing adjustment.

# Create a mapping for time of day
time_of_day_mapping = {
    'Night': '21:00:00',  # Assuming 'Night' corresponds to 9:00 PM
    'Evening': '18:00:00',
    'Afternoon': '15:00:00',
    # Add mappings for other time categories
}

# Replace 'Time_of_Booking' with the corresponding time values
data['Time_of_Booking'] = data['Time_of_Booking'].map(time_of_day_mapping)

# Convert 'Time_of_Booking' to datetime
data['Time_of_Booking'] = pd.to_datetime(data['Time_of_Booking'], format='%H:%M:%S')

# Extract hour of the day
data['time_of_day'] = data['Time_of_Booking'].dt.hour

# Define peak hours
peak_hours = [17, 18, 19]

# Create time multiplier
data['time_multiplier'] = np.where(data['time_of_day'].isin(peak_hours), 1.5, 1.0)

# Update adjusted_ride_cost considering time-based pricing
data['adjusted_ride_cost'] *= data['time_multiplier']

# Example: Loyalty-based pricing adjustment
loyal_customer_discount = 0.9  # 10% discount for loyal customers
data['loyalty_multiplier'] = np.where(data['Customer_Loyalty_Status'] == 'Silver', loyal_customer_discount, 1.0)

# Update adjusted_ride_cost considering loyalty-based pricing
data['adjusted_ride_cost'] *= data['loyalty_multiplier']

"""Training a Predictive Model"""

#preprocessing the data
import pandas as pd
import numpy as np
from sklearn.preprocessing import StandardScaler

def data_preprocessing_pipeline(data):
    #Identify numeric and categorical features
    numeric_features = data.select_dtypes(include=['float', 'int']).columns
    categorical_features = data.select_dtypes(include=['object']).columns

    #Handle missing values in numeric features
    data[numeric_features] = data[numeric_features].fillna(data[numeric_features].mean())

    #Detect and handle outliers in numeric features using IQR
    for feature in numeric_features:
        Q1 = data[feature].quantile(0.25)
        Q3 = data[feature].quantile(0.75)
        IQR = Q3 - Q1
        lower_bound = Q1 - (1.5 * IQR)
        upper_bound = Q3 + (1.5 * IQR)
        data[feature] = np.where((data[feature] < lower_bound) | (data[feature] > upper_bound),
                                 data[feature].mean(), data[feature])

    #Handle missing values in categorical features
    data[categorical_features] = data[categorical_features].fillna(data[categorical_features].mode().iloc[0])

    return data

#converting vehicle type into numerical feature
data["Vehicle_Type"] = data["Vehicle_Type"].map({"Premium": 1,
                                           "Economy": 0})

#splitting data
from sklearn.model_selection import train_test_split
x = np.array(data[["Number_of_Riders", "Number_of_Drivers", "Vehicle_Type", "Expected_Ride_Duration"]])
y = np.array(data[["adjusted_ride_cost"]])

x_train, x_test, y_train, y_test = train_test_split(x,
                                                    y,
                                                    test_size=0.2,
                                                    random_state=42)

# Reshape y to 1D array
y_train = y_train.ravel()
y_test = y_test.ravel()

# Training a random forest regression model
from sklearn.ensemble import RandomForestRegressor
model = RandomForestRegressor()
model.fit(x_train, y_train)

"""Testing"""

def get_vehicle_type_numeric(vehicle_type):
    vehicle_type_mapping = {
        "Premium": 1,
        "Economy": 0
    }
    vehicle_type_numeric = vehicle_type_mapping.get(vehicle_type)
    return vehicle_type_numeric

# Predicting using user input values
def predict_price(number_of_riders, number_of_drivers, vehicle_type, Expected_Ride_Duration):
    vehicle_type_numeric = get_vehicle_type_numeric(vehicle_type)
    if vehicle_type_numeric is None:
        raise ValueError("Invalid vehicle type")

    input_data = np.array([[number_of_riders, number_of_drivers, vehicle_type_numeric, Expected_Ride_Duration]])
    predicted_price = model.predict(input_data)
    return predicted_price

# Example prediction using user input values
user_number_of_riders = 50
user_number_of_drivers = 25
user_vehicle_type = "Economy"
Expected_Ride_Duration = 30
predicted_price = predict_price(user_number_of_riders, user_number_of_drivers, user_vehicle_type, Expected_Ride_Duration)
print("Predicted price:", predicted_price)

#comparison between the actual and predicted values
import plotly.graph_objects as go

# Predict on the test set
y_pred = model.predict(x_test)

# Create a scatter plot with actual vs predicted values
fig = go.Figure()

fig.add_trace(go.Scatter(
    x=y_test.flatten(),
    y=y_pred,
    mode='markers',
    name='Actual vs Predicted'
))

# Add a line representing the ideal case
fig.add_trace(go.Scatter(
    x=[min(y_test.flatten()), max(y_test.flatten())],
    y=[min(y_test.flatten()), max(y_test.flatten())],
    mode='lines',
    name='Ideal',
    line=dict(color='red', dash='dash')
))

fig.update_layout(
    title='Actual vs Predicted Values',
    xaxis_title='Actual Values',
    yaxis_title='Predicted Values',
    showlegend=True,
)

fig.show()

#Handling invalid user input
def get_vehicle_type_numeric(vehicle_type):
    vehicle_type_mapping = {"Premium": 1, "Economy": 0}
    return vehicle_type_mapping.get(vehicle_type, -1)  # Return -1 for unknown types

#Evaluation Metrics
from sklearn.metrics import mean_absolute_error, mean_squared_error

# Calculate evaluation metrics
mae = mean_absolute_error(y_test, y_pred)
mse = mean_squared_error(y_test, y_pred)
rmse = np.sqrt(mse)

print(f'Mean Absolute Error: {mae:.2f}')
print(f'Mean Squared Error: {mse:.2f}')
print(f'Root Mean Squared Error: {rmse:.2f}')

#Interpretation of Scatter Plot(Model's behaviour)
fig.add_annotation(
    go.layout.Annotation(
        x=max(y_test.flatten()),
        y=max(y_test.flatten()),
        text='Ideal Prediction',
        showarrow=True,
        arrowhead=2,
        arrowcolor='black',
        arrowwidth=2,
    )
)

#Model Interpretability
feature_importances = model.feature_importances_
feature_names = ["Number_of_Riders", "Number_of_Drivers", "Vehicle_Type", "Expected_Ride_Duration"]

# Bar chart for feature importances
fig = go.Figure(go.Bar(x=feature_names, y=feature_importances, marker_color='skyblue'))
fig.update_layout(title='Feature Importances', xaxis_title='Features', yaxis_title='Importance')
fig.show()